<?php

function og_help($section) {
  $output = "";

  switch ($section) {
    case 'admin/help#og':
      break;
    case 'admin/modules#description':
      return t("Organic groups");
    case 'node/add/og':
      return variable_get('og_help', '');
    case 'node/add#og':
      return t("A group provides home page for like minded users. There they post articles about their shared interest.");
  }
}

function og_menu($may_cache) {
  global $user;

  if ($may_cache) {
    $items[] = array('path' => 'node/add/og', 'title' => t('group'), 'access' => user_access('create groups'));
    $items[] = array('path' => 'og', 'callback' => 'og_list_groups_page', 'title' => t('groups'), 'weight' => 3, 'access' => TRUE);
    $access = $user->uid; // login is required
    $items[] = array('path' => 'og/subscribe', 'type' => MENU_CALLBACK, 'callback' => 'og_subscribe', 'access' => $access, 'title' => t('subscribe to group'));
    $items[] = array('path' => 'og/unsubscribe', 'type' => MENU_CALLBACK, 'callback' => 'og_unsubscribe', 'access' => $access, 'title' => t('unsubscribe from group'));
    $items[] = array('path' => 'og/approve', 'type' => MENU_CALLBACK, 'callback' => 'og_approve', 'access' => $access, 'title' => t('approve subscription request'));
    $items[] = array('path' => 'og/deny', 'type' => MENU_CALLBACK, 'callback' => 'og_deny', 'access' => $access, 'title' => t('deny subscription request'));
    $items[] = array('path' => 'og/create_admin', 'type' => MENU_CALLBACK, 'callback' => 'og_create_admin', 'access' => $access, 'title' => t('create group administrator'));
    $items[] = array('path' => 'og/delete_admin', 'type' => MENU_CALLBACK, 'callback' => 'og_delete_admin', 'access' => $access, 'title' => t('delete group administrator'));
    $items[] = array('path' => 'og/remove_node', 'type' => MENU_CALLBACK, 'callback' => 'og_remove_node', 'access' => $access, 'title' => t('remove post from group'));
    $items[] = array('path' => 'og/access_denied', 'type' => MENU_CALLBACK, 'callback' => 'og_access_denied', 'title' => t('groups'), 'access' => TRUE);
    $items[] = array('path' => 'og/albums', 'callback' => 'og_albums_page', 'title' => t('album'), 'type' => MENU_CALLBACK, 'access' => TRUE);
    $items[] = array('path' => 'admin/og/updatedb', 'type' => MENU_CALLBACK, 'callback' => '_og_updatedb', 'title' => t('update db'), 'access' => user_access('administer organic groups'));
  }
  else {
    $subs = og_get_subscriptions($user->uid);
    if (is_array($subs)) {
      foreach ($subs as $key => $sub) {
        $items[] = array('path' => "og/view/$key", 'callback' => 'og_nodeview', 'title' => $sub['title'], 'callback arguments' => $key, 'access' => TRUE);
        $items[] = array('path' => "og/users/$key", 'callback' => 'og_list_users_page', 'title' => t('groups'), 'callback arguments' => $key, 'type' => MENU_CALLBACK, 'access' => TRUE);
      }
    }

    // handle 'initialize' checkbox from the settings page. should this checkbox to own page, off of settings page. move this code withit.
    if (isset($_POST['edit']['og_enabled']) && user_access('administer organic groups')) {
      _og_update_db($_POST['edit']['og_enabled']);
    }

    //stash path so that its available if we have a 403. see http://drupal.org/node/13621
    $_GET['q_original'] = $_GET['q'];

  }
  return $items;
}

function og_perm() {
  return array('create groups', 'administer organic groups');
}

function og_nodeview($gid) {
  drupal_goto("node/$gid");
}

function og_dest() {
  if ($dest = $_REQUEST['dest']) {
    drupal_goto($dest);
   }
}

function og_approve($gid, $uid) {
  if (node_access('update', array('nid' => $gid, 'status' => 1))) {
    $sql = "REPLACE INTO {node_access} (nid, gid, realm, grant_view) VALUES (%d, %d, 'og_uid', 1)";
    db_query($sql, $gid, $uid);
    drupal_set_message(t('Subscription request approved.'));
    og_dest();
  }
  else {
    drupal_access_denied();
  }
}

function og_deny($gid, $uid) {
  if (node_access('update', array('nid' => $gid, 'status' => 1))) {
    $sql = "DELETE FROM {node_access} WHERE nid=%d AND gid=%d AND realm='og_uid'";
    db_query($sql, $gid, $uid);
    drupal_set_message(t('Subscription request denied.'));
    og_dest();
  }
  else {
    drupal_access_denied();
  }
}

function og_create_admin($gid, $uid) {
  if (node_access('update', array('nid' => $gid, 'status' => 1))) {
    $sql = "REPLACE INTO {node_access} (nid, gid, realm, grant_view, grant_update) VALUES (%d, %d, 'og_uid', 1, 1)";
    db_query($sql, $gid, $uid);
    drupal_set_message(t('User was promoted to <em> group administrator</em>'));
    og_dest();
  }
  else {
    drupal_access_denied();
  }
}

function og_delete_admin($gid, $uid) {
  if (node_access('update', array('nid' => $gid, 'status' => 1))) {
    $sql = "REPLACE INTO {node_access} (nid, gid, realm, grant_view, grant_update) VALUES (%d, %d, 'og_uid', 1, 0)";
    db_query($sql, $gid, $uid);
    drupal_set_message(t('User is no longer a group administrator'));
    og_dest();
  }
  else {
    drupal_access_denied();
  }
}

function og_remove_node($gid, $nid) {
  if (node_access('update', array('nid' => $gid, 'status' => 1))) {
    $node = node_load(array('nid' => $nid));
    og_delete_folksonomy($node);
    $sql = "DELETE FROM {node_access} WHERE nid=%d AND gid=%d AND realm='og_group'";
    db_query($sql, $nid, $gid);
    drupal_set_message(t('Post removed from group.'));
    og_dest();
  }
  else {
    drupal_access_denied();
  }
}

function og_delete_folksonomy($node) {
  foreach ($node->og_groups as $gid) {
    $realm = "og_group_$gid";
    module_invoke('folksonomy', 'delete', array('realm' => $realm, 'id' => $node->nid));
  }
}

function og_subscribe($gid, $uid = NULL) {
  global $user;
  if (is_null($uid)) {
    $uid = $user->uid;
  }
  if ($uid != $user->uid && !node_access('update', array('nid' => $gid, 'status' => 1))) {
    // only admins can subscribe another person
    drupal_access_denied();
  }

  $names = array('nid', 'realm', 'gid', 'grant_view', 'grant_update');
  $values = array($gid, "'og_uid'", $uid);

  // selective groups must approve in all members
  // if you can't view/edit/delete, you are *requesting* membership in the group
  // if you can view, you are a member
  // if you can edit, you are an admin
  $node = node_load(array('nid' => $gid));
  if ($node->og_selective) {
    $values[] = 0;
    $values[] = 0;
    drupal_set_message(t('Subscription request awaits approval by an administrator.'));
  }
  else {
    $values[] = 1;
    $values[] = 0;
    drupal_set_message(t('User subscribed to group.'));
  }
  $sql = 'REPLACE INTO {node_access} ('. implode(',', $names). ') VALUES ('. implode(',', $values). ')';
  db_query($sql);
  og_dest();
}

function og_unsubscribe($gid, $uid = NULL) {
  global $user;
  if (is_null($uid)) {
    $uid = $user->uid;
  }
  if ($uid != $user->uid && !node_access('update', array('nid' => $gid, 'status' => 1))) {
    // only admins can unsubscribe another person
    drupal_access_denied();
  }

  $sql = "DELETE FROM {node_access}  WHERE gid = %d AND nid = %d AND realm = 'og_uid'";
  db_query($sql, $uid, $gid);
  drupal_set_message(t('User unsubscribed from group.'));
  og_dest();
}

function og_get_subscriptions($uid) {
  static $subscriptions = array(), $options = array();

  if (!isset($subscriptions[$uid])) {
    $sql = "SELECT na.*, n.title FROM {node_access} na INNER JOIN {node} n ON na.nid = n.nid WHERE gid = %d AND realm = 'og_uid' AND grant_view = 1";
    $result = db_query($sql, $uid);
    while ($row = db_fetch_object($result)) {
      $subscriptions[$uid][$row->nid]['title'] = $row->title;
      $subscriptions[$uid][$row->nid]['grant_view'] = $row->grant_view;
      $subscriptions[$uid][$row->nid]['grant_update'] = $row->grant_update;
      $subscriptions[$uid][$row->nid]['grant_delete'] = $row->grant_delete;
    }
  }
  return $subscriptions[$uid] ? $subscriptions[$uid] : array();
}

/**
 * Implementation of hook_access().
 */
function og_access($op, $node) {
  global $user;

  if ($op == 'create') {
    return user_access('create groups') && $user->uid;
  }
}

function og_list_users_sql($min_grant = 1) {
  return "SELECT u.uid, u.name, na.* FROM {node_access} na INNER JOIN {users} u ON na.gid = u.uid AND na.nid = %d WHERE u.status > 0 AND realm = 'og_uid' AND grant_view >= $min_grant ORDER BY u.name ASC";
}

function og_list_users_page($gid) {
  $sql = og_list_users_sql(0);
  $result = pager_query($sql, 500, 0, NULL, $gid);
  $header[] = t("Name");
  $access = node_access('update', array('nid' => $gid, 'status' => 1));
  if ($access) {
    $header[] = array('data' => t('Operations'), 'colspan' => 2);
  }
  // prepend the group owner
  $node = node_load(array('nid' => $gid));
  $i=0;
  $rows[$i][] = format_name($node). '&nbsp;<em>'. t('manager'). '</em>';
  if ($access) {
    $rows[$i][] = l(t('edit group'), "node/$gid/edit");
    $rows[$i][] = '&nbsp;';
  }
  $i++;
  while ($account = db_fetch_object($result)) {
      if ($account->uid != $node->uid) {
        $rows[$i][] = format_name($account);
        if ($access) {
          if ($account->grant_view) {
            $rows[$i][] = l(t('unsubscribe'), "og/unsubscribe/$gid/$account->uid", array(), "dest=og/users/$gid");
            if ($account->grant_update) {
              $rows[$i][] = l(t('admin: remove'), "og/delete_admin/$gid/$account->uid", array(), 'dest='. $_GET['q']);
            }
            else {
              $rows[$i][] = l(t('admin: create'), "og/create_admin/$gid/$account->uid", array(), 'dest='. $_GET['q']);
            }
          }
          else {
            $rows[$i][] = l(t('approve'), "og/approve/$gid/$account->uid", array(), "dest=og/users/$gid");
            $rows[$i][] = l(t('deny'), "og/deny/$gid/$account->uid", array(), "dest=og/users/$gid");
          }
        }
        $i++;
      }
  }
  if ($pager = theme('pager', NULL, 500)) {
    $rows[$i][] = array('data' => $pager, 'colspan' => 2);
  }
  $output = theme('table', $header, $rows);
  $bc = array(l(t('Home'), ''), l(t('groups'), 'og'), l($node->title, "node/$node->nid"));
  print theme('page', $output, t('Subscribers'), $bc);
}

function og_list_groups_page() {
  global $user;

  if (variable_get('og_selective_listed', 0)) {
    $result = pager_query('SELECT DISTINCT(n.nid), n.title, n.body, n.uid, u.name FROM {node} n INNER JOIN {users} u ON n.uid = u.uid WHERE n.status=1 AND n.type = \'og\' ORDER BY n.nid DESC',50);
  }
  else {
    $result = pager_query('SELECT DISTINCT(n.nid), n.title, n.body, n.uid, u.name FROM {node} n '. node_access_join_sql(). ' INNER JOIN {users} u ON n.uid = u.uid INNER JOIN {og} ON n.nid = og.nid WHERE '. node_access_where_sql(). " AND og.selective = 0 AND n.status=1 AND n.type = 'og' ORDER BY n.nid DESC",50);
  }
  $header = array(t("Title"), t('Subscribers'), t("Owner"), t('Description'));
  $subscriptions = og_get_subscriptions($user->uid);

  while ($node = db_fetch_object($result)) {
    $cnt = db_num_rows(db_query(og_list_users_sql(), $node->nid));
    $rows[] = array(
      array("data" => l($node->title, "node/$node->nid")),
      array("data" => in_array($node->nid, array_keys($subscriptions)) ? l($cnt, "og/users/$node->nid") : $cnt),
      array("data" => format_name($node)),
      array("data" => check_output($node->body)),
    );
  }
  if (!$rows) {
    $rows[] = array(array('data' => t('No groups'), 'colspan' => 4));
  }
  $output = theme('table', $header, $rows). theme('pager', NULL, 50);
  print theme('page', $output);
}

//  when you view a group, you really see some facts about the group and then a list of nodes affiliated with that group
function og_view(&$node, $teaser = FALSE, $page = FALSE) {
  if ($teaser || !$page) {
    $node = node_prepare($node, $teaser);
  }
  else {
    // get all the group nodes. we have to break this list into two steps in case user is not a member of the group and post is public
    $result = db_query("SELECT DISTINCT(n.nid), n.status FROM {node} n INNER JOIN {node_access} na ON n.nid = na.nid WHERE na.gid = $node->nid AND na.realm = 'og_group' AND n.status=1 AND n.type NOT IN ('og', 'image') ORDER BY n.created DESC");
    if (!db_num_rows($result)) {
      drupal_set_message(t('No posts yet in this group.'));
    }
    else {
      while ($onenode = db_fetch_array($result)) {
        // make sure user can view each node
        if (node_access('view', $onenode)) {
          $nodes .= node_view(node_load($onenode), TRUE, FALSE);
        }
      }
      if (!$nodes) {
        drupal_set_message(t('There are no public posts in this group.'));
      }
    }
    $bc = array(l(t('Home'), ''), l(t('groups'), 'og'));
    drupal_set_breadcrumb($bc);
  }
  $node->body = $output. $nodes;
  return $node;
}

function og_form(&$node, &$param) {
  if (function_exists('taxonomy_node_form')) {
    $output .= implode('', taxonomy_node_form('og', $node));
  }
  $output .= form_textfield(t('Description'), 'body', $node->body, 70, 150, '', NULL, TRUE);
  if (isset($_POST['edit']['og_selective'])) {
    $selective = $_POST['edit']['og_selective'];
  }
  elseif ($node->nid) {
    $selective = $node->og_selective;
  }
  else {
    $selective = 1;
  }
  $output .= form_checkbox(t('Selective'), 'og_selective', 1, $selective, t('Check this box if new subscription requests require manual approval. Otherwise, they will be automatically approved.'));
  $output .= filter_form('format', $node->format);
  return $output;
}

function og_node_load_public($node) {
  $sql = "SELECT grant_view FROM {node_access} WHERE nid = %d AND gid=0 AND realm='og_group'";
  $gv = db_result(db_query($sql, $node->nid));
  $node->og_public = $gv;
  return $node;
}

// returns all the group affiliations for a given node.
function og_get_node_groups($node) {
  if ($node->type != 'og') {
    $sql = "SELECT na.gid, n.title FROM {node_access} na INNER JOIN {node} n ON na.gid = n.nid WHERE na.nid = %d AND na.realm='og_group' AND na.gid != 0";
    $result = db_query($sql, $node->nid);
    while ($row = db_fetch_object($result)) {
      $groups[$row->gid] = $row->title;
    }
    return $groups ? $groups : array();
  }
}

// comments are not allowed on group nodes, since we don;t have any nice way to present them
function og_validate(&$node) {
  $node->comment = 0;
}

function og_node_name($node) {
  return t('group');
}

function og_load($node) {
  $sql = 'SELECT selective AS og_selective FROM {og} WHERE nid = %d';
  $result = db_query($sql, $node->nid);
  return db_fetch_object($result);
}

function og_insert($node) {
  $sql = 'INSERT INTO {og} (nid, selective) VALUES (%d, %d)';
  db_query($sql, $node->nid, $node->og_selective);
}

function og_update($node) {
  $sql = 'UPDATE {og} SET selective=%d WHERE nid=%d';
  db_query($sql, $node->og_selective, $node->nid);
}

/**
 * Implementation of hook_nodeapi().
 *
*/
function og_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  switch ($op) {
    case 'load':
      if ($node->type != 'og') {
        $node = og_node_load_public($node);
      }
      if ($grps = og_get_node_groups($node)) {
        // TODO: Refactor so we don't need 2 arrays.
        $node->og_groups = array_keys($grps);
        $node->og_groups_names = array_values($grps);
      }
      break;
    case 'validate':
      if ($node->type != 'og' && !in_array($node->type, variable_get('og_omitted', array()))) {
        if (variable_get('og_audience_required', 0) && empty($node->og_groups) && $_POST) {
          form_set_error('og_groups', t('You must select an audience in order to post.'));
        }
        $vis = variable_get('og_visibility', 0);
        switch ($vis) {
          // case 2 is handled in og_nodeapi('validate')
          case 1: // visible in and out of group
            $node->og_public = 1;
            break;
          case 0: // visible only in group
            $node->og_public = 0;
            break;
        }
      }
      break;
    case 'delete':
      og_delete_folksonomy($node);
      og_delete_permissions($node);
      break;
    case 'insert':
    case 'update':
      og_save_permissions($node);
      break;
    case 'form post':
      return og_nodeapi_form($node);
  }
}

function og_nodeapi_form($node) {
  $edit = $_REQUEST['edit'];
  if ($node->type == 'og' || in_array($node->type, variable_get('og_omitted', array()))) {
    return form_hidden('og_public', 1);
  }
  else {
    $required = variable_get('og_audience_required', 0);
    $subs = og_get_subscriptions($node->uid);
    foreach ($subs as $key => $val) {
      $options[$key] = $val['title'];
    }
    if (!$options && $required && $_POST) {
      drupal_set_message(t('You must subscribe to a group before posting.'), 'error');
    }

    $vis = variable_get('og_visibility', 0);
    switch ($vis) {
      case 2: //user decides how public the post is
        if (isset($edit['og_public'])) {
          $public = $edit['og_public'];
        }
        elseif ($node->nid) {
          $public = $node->og_public;
        }
        else {
          $public = 1;
        }
        $output .= form_checkbox(t('Public'), 'og_public', 1, $public, t('Show this post to everyone or only to members of the groups below.'));
        break;
    }

    if (isset($edit['og_groups'])) {
      $groups = $edit['og_groups'];
    }
    elseif ($node->nid) {
      $groups = $node->og_groups;
    }
    else {
      $groups = array();
    }

    $output .= form_checkboxes(t('Audience'), 'og_groups', $groups, $options, t('Show this post in these groups.'), NULL, $required);

    return $output;
  }
}

function og_user($op, &$edit, &$account, $category) {
  global $user;

  switch ($op) {
    case 'view':
      if ($account->uid == $user->uid || user_access('administer organic groups')) {
        if ($subs = og_get_subscriptions($account->uid)) {
          foreach ($subs as $key => $val) {
            $links[] = l($val['title'], "node/$key");
          }
          return array('Groups' => theme('node_list', $links));
        }
      }
      break;
  }
}

/**
 * In the 'og_uid' realm, the gid is a uid. This is used to determine a whether a user
 * is a member of a group, and what his permissions are in that group (view/update/delete). When a
 * user has permissions of 0,0,0 he is considered to be 'applying' for access to a private group
 *
 * In the 'og_group' realm, the gid is a nid of a group. This is used
 * to store which nodes should show up in which groups. Further, the 'grant_view'
 * permission determines whether a group is selective (i.e. private) or not (for 'og' nodes).
 *
**/
function og_node_grants($account, $op) {
  $grants['og_uid'][] = $account->uid;
  $grants['og_group'][] = 0;

  // get subscriptions
  if ($subscriptions = og_get_subscriptions($account->uid)) {
    foreach ($subscriptions as $key => $val) {
      if ($val["grant_$op"]) {
        $grants['og_group'][] = $key;
      }
    }
  }
  return $grants ? $grants : array();
}

function og_save_permissions(&$node) {
  global $user;

  $sql = "DELETE FROM {node_access} WHERE realm = 'og_group' AND nid = %d";
  db_query($sql, $node->nid);

  if ($node->type != 'og') {
    // put the post into each selected group
    if (is_array($node->og_groups)) {
      foreach($node->og_groups as $gid) {
        $sql = "INSERT INTO {node_access} (nid, gid, realm, grant_view) VALUES (%d, %d, 'og_group', 1)";
        db_query($sql, $node->nid, $gid);
      }
    }

    // if the public checkbox was selected, give a universal grant for this node
    if ($node->og_public) {
      $sql = "INSERT INTO {node_access} (nid, gid, realm, grant_view) VALUES (%d, 0, 'og_group', 1)";
      db_query($sql, $node->nid);
    }
  }
  else {
    // all groups are publically viewable (though their posts may not be)
    // dprint_r($node);
    $sql = "INSERT INTO {node_access} (nid, gid, realm, grant_view) VALUES (%d, 0, 'og_group', 1)";
    db_query($sql, $node->nid);

    // make sure the node owner is a full powered subscriber
    $sql = "REPLACE INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, 'og_uid', 1, 1, 1)";
    db_query($sql, $node->nid, $node->uid);
  }
}

function og_delete_permissions(&$node) {
  // delete all existing grants for this module
  $sql = "DELETE FROM {node_access} WHERE realm = '%s' AND nid = $node->nid";
  $realms = array('og_group', 'og_uid');
  foreach ($realms as $realm) {
    db_query($sql, $realm);
  }
}

/**
 * Update the node_access table when a user enables/disables the module in the
 * settings page.  Because Drupal does not, at this
 * time, provide hooks that run automatically upon the enabling/disabling of a
 * module in the admin/modules page, we must force the site-admin to explicitly
 * enable/disable a module on the settings page, in
 * addition to enabling/disabling the module in the admin/modules page.
 *
 * Here, if the user is enabling the module, we make sure the default entry in
 * the node_access table is deleted and walk through all the nodes in the node_table
 * and grant all view access as is the default case when this module is not
 * enabled.  We only do this for nodes whose permissions haven't been set before by
 * this module.  It is possible that a site-admin may have previously enabled the
 * module before disabling it.  Upon re-enabling, we want to account for the old
 * permissions set by the module by not re-inserting entries for them.
 *
 * Disabling the module simply requires re-inserting the default entry back into
 * the node access table to give 'view' perms to everyone for everything:
 * (0, 0, 'all', 1, 0, 0)
 */
function _og_update_db($enable) {
  if (!$enable) {
    // We use the delete statement to avoid inserting a duplicate entry into the database.
    // Without the DELETE query, this can happen when a site admin has already enabled the modules
    // from the settings page and goes back to it and resaves the enabled setting.
    db_query('REPLACE INTO {node_access} VALUES (0, 0, \'all\', 1, 0, 0)');
    drupal_set_message(t('Organic groups access control has been disabled. You may now disable the module on the <em>%modules</em> page', array('%modules' => l(t('admin/modules'), 'admin/modules'))));
  }
  else { // the module was just enabled or re-enabled; provide default view access to everyone for nodes that were created
         // between the previous disabling of the module and the current enabling of the module;
         // nodes that were created during a previous enabled period are left-alone.
         // Permissions for those nodes will be the same as when the module was previously enabled.
    db_query('DELETE from {node_access} WHERE nid=0 AND gid=0 AND realm=\'all\' AND grant_view=1 AND grant_update=0 AND grant_delete=0');

    // Assign universal grant to all non-group nodes which don't already have any grants from this module
    $result = db_query("SELECT n.nid FROM {node} n LEFT JOIN {node_access} na ON n.nid = na.nid AND realm LIKE '%og%' WHERE n.type != 'og' AND ISNULL(na.gid)");
    while ($row = db_fetch_object($result)) {
      $sql = "INSERT INTO {node_access} (nid, gid, realm, grant_view) VALUES (%d, 0, 'og_group', 1)";
      db_query($sql, $row->nid);
    }
    drupal_set_message(t('Organic groups access control enabled.'));
  }
}

// called to determine whether or not to show group block
// called during a 403 page and we show appropriate msg if no posts are accessible
function og_is_group() {
  // these are the 3 pages when we want the blocks to appear
  if (arg(0) == 'node' && is_numeric(arg(1)) && !arg(2)) {
    $nid = arg(1);
  }
  elseif (arg(0) == 'og' && arg(1) == 'users') {
    $nid = arg(2);
  }
  elseif (arg(0) == 'og' && arg(1) == 'albums') {
    $nid = arg(2);
  }

  if ($nid) {
    $node = node_load(array('nid' => $nid));
    if ($node->type == 'og') {
      $node->og_msg = t('There are no public posts in this group.');
      return $node;
    }
  }
}

function og_access_denied() {
  $_GET['q'] = $_GET['q_original']; // see og_menu(!$may_cache)
  $node = og_is_group();
  if (!$node) {
    $node->og_msg = message_access();
    $node->title = t('Access denied');
  }
  print theme('page', $node->og_msg, $node->title);
}

/**
 * Implementation of hook_block().
 */
function og_block($op = 'list', $delta = 0) {
  if ($op == 'list') {
    $blocks[0]['info'] = t('Group details');
    $blocks[1]['info'] = t('Group albums');
    $blocks[2]['info'] = t('Group subscribers');
    return $blocks;
  }
  else {
    switch ($delta) {
      case 0:
        return og_block_details();
      case 1:
        return og_block_albums();
      case 2:
        return og_block_subscribers();
    }
  }
}

function og_albums_page($gid, $str_tags) {
  list($operator, $tags) = folksonomy_parse_request($str_tags);
  if ($tags) {
    $title = str_replace(array(',', '+'), ', ', $str_tags);
    $node = node_load(array('nid' => $gid));
    $bc = array(l(t('Home'), ''), l(t('groups'), 'og'), l($node->title, "node/$node->nid"));
    $result = folksonomy_select_nodes($tags, $operator, 'image', 'og_group_'. $node->nid);
    // append 'create album' link if available. a bit messy for now.
    if (user_access('create images') && module_exist('folksonomy') && user_access('access bulk upload')) {
      $links[] = l(t('add to this album'), 'bu/standard', array(), "edit[og_groups][]=$node->nid&edit[bu_tags]=$str_tags");
    }
    $output = theme('item_list', $links);
    $output .= taxonomy_render_nodes($result);
    print theme('page', $output, $title, $bc);
  }
  else {
    drupal_not_found();
  }
}

function og_block_albums() {
  if ($node = og_is_group()) {
    $sql = "SELECT DISTINCT(name) FROM {folksonomy} WHERE realm = 'og_group_$node->nid' ORDER BY id DESC";
    $result = db_query($sql);
    while ($row = db_fetch_object($result)) {
      $links[] = l($row->name, "og/albums/$node->nid/$row->name");
    }
    if ($links) {
      $block['content'] = theme('item_list', $links);
      $block['subject'] = t('Albums');
      return $block;
    }
  }
}

function og_block_subscribers() {
  global $user;
  if ($node = og_is_group()) {
    $subscriptions = og_get_subscriptions($user->uid);
    if (in_array($node->nid, array_keys($subscriptions))) {
      $sql = og_list_users_sql(0);
      $result = db_query_range($sql, $node->nid, 0, 15);
      while ($row = db_fetch_object($result)) {
        $link = format_name($row);
        if (!$row->grant_view) {
          $link .= theme_mark();
        }
        $links[] = $link;
      }
      if ($links) {
        if (count($links) > 14) {
          array_pop($links);
          $append = '<div class="more-link">'. l(t('more'), "og/users/$node->nid", array('title' => t('View all subscribers.'))) .'</div>';;
        }
        $block['content'] = theme('item_list', $links). $append;
        $block['subject'] = t('Recent subscribers');
        return $block;
      }
    }
  }
}

function og_block_details() {
  global $user;

  if ($node = og_is_group()) {
    $output = '<div id="og_description">'. $node->body. '</div><br />';
    if ($_POST['op'] != t('Preview')) {
      $subscribed = FALSE;
      $result = db_query(og_list_users_sql(0), $node->nid);
      $cntall = db_num_rows($result);
      $cntpending = 0;
      while ($row = db_fetch_object($result)) {
        if ($row->grant_view == 0) {
          $cntpending++;
        }
        if ($row->uid == $user->uid) {
          if ($row->grant_view) {
            $subscription = 'active';
          }
          else {
            $subscription = 'requested';
          }
        }
      }
      if ($subscription == 'active') {
        $links = og_create_links($node);
        $txt = format_plural($cntall-$cntpending, '1 subscriber', '%count subscribers');
        $txt = l($txt, "og/users/$node->nid");
        $txt .= $cntpending ? " ($cntpending)" : '';
        $links[] = $txt;
        $links[] = t('age: %age', array('%age' => format_interval(time()-$node->created, 2)));
        $links[] = t('manager: %name', array('%name' => format_name($node)));
        // don't allow manager to unsubscribe
        if ($user->uid != $node->uid) {
          $links[] = l(t('unsubscribe'), "og/unsubscribe/$node->nid", array(), 'dest=og');
        }
      }
      elseif ($subscription == 'requested') {
        $links[] = t('Your subscription request awaits approval.');
        $links[] = l(t('delete request'), "og/unsubscribe/$node->nid", array(), 'dest=og');
      }
      elseif ($user->uid) {
        if ($node->og_selective) {
          $txt = t('request subscription');
        }
        else {
          $txt = t('subscribe');
        }
        $links[] = l($txt, "og/subscribe/$node->nid", array(), "dest=node/$node->nid");
      }
      $output .= theme('item_list', $links);
    }
    $block['content'] = $output;
    $block['subject'] = $node->title;
    return $block;
  }
}

// $group is an object containing the group node
function og_create_links($group) {
  foreach (node_list() as $type) {
    // image is filtered out here because we expect images to be added from within albums
    $exempt = array_merge(array('og', 'image'), variable_get('og_omitted', array()));
    if (!in_array($type, $exempt) && node_access('create', $type)) {
      $name = node_invoke($type, 'node_name');
      $links[] = l(t('create %type', array('%type' => $name)), "node/add/$type", array('title' => t('Add a new %s in this group.', array('%s' => $name))), "edit[og_groups][]=$group->nid");
    }
  }
  // append 'create album' link if available. a bit messy for now.
  if (user_access('create images') && module_exist('folksonomy') && user_access('access bulk upload')) {
    $links[] = l(t('create album'), 'bu/standard', array(), "edit[og_groups][]=$group->nid");
  }
  return $links ? $links : array();
}

function og_link($type, $node = 0, $main) {
  global $user;

  if ($node->og_groups) {
    if ($mygroups = og_get_subscriptions($user->uid)) {
      foreach ($mygroups as $key => $grp) {
        if ($grp['grant_update'] && in_array($key, $node->og_groups)) {
          $links[] = l(t('remove from group'), "og/remove_node/$key/$node->nid", array('title' => $grp['title']), "dest=node/$key");
          break;
        }
      }
    }
  }
  return $links ? $links : array();
}

function og_settings() {
  $output = form_textarea(t('Explanation or submission guidelines'), 'og_help', variable_get('og_help', ''), 70, 5, t('This text will be displayed at the top of the group submission form.  It is useful for helping or instructing your users.'));
  $output .= form_checkbox(t('List selective groups'), 'og_selective_listed', 1, variable_get('og_selective_listed', 0), t('Selective groups appear in the %s. Selective groups require new subscription requests to be manually approved.', array('%s' => l('list of groups page', 'og'))));
  $options = array(t('Visible only within the targeted groups'), t('Visible within the targeted groups and on other pages'), t('Visibility to be determined by the author/editor using a checkbox on the posting form'));
  $output .= form_radios(t('Visibility of posts'), 'og_visibility', variable_get('og_visibility', 0), $options, t('Determine how broadly available a given post should be when it is affiliated with a group'));
  $options = array(t('optional'), t('required'));
  $output .= form_radios(t('Audience required'), 'og_audience_required', variable_get('og_audience_required', 0), $options, t('Do you require that all posts be affiliated with a group? If so, new users will be unable to complete a post until they join a group.'));
  unset($options);
  foreach (node_list() as $type) {
    // we exclude image becuase those will usually be added from within an album
    if (!in_array($type, array('image', 'og'))) {
      $options[$type] = module_invoke($type, 'node_name');
    }
  }
  $output .= form_select(t('Omitted content types'), 'og_omitted', variable_get('og_omitted', array()), $options, t('Select any node types which should <em>not</em> participate in the Audience targetting system.'), 0, TRUE);
  $output .= form_checkbox(t('Initialize access control'), 'og_enabled', 1, variable_get('og_enabled', 0), t('Perform the queries necessary to enable or disable groups access control. You should perform this only once.'));
  return $output;
}

?>
